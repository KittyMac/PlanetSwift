//
// Autogenerated by gaxb at 11:45:55 AM on 01/14/15
//

import UIKit

private let Constraint_parentKeyword = "parent"

public class Constraint: ConstraintBase {

	internal(set) public var constraints = [NSLayoutConstraint]()
    public var constraint: NSLayoutConstraint? { return constraints.first }
	
	//MARK: - enum conversion
	
	public class func layoutAttributeFromEnum(attribute:PlanetUI.LayoutAttribute) -> NSLayoutAttribute {
		
		switch(attribute) {
		case .left:
			return .Left
		case .right:
			return .Right
		case .top:
			return .Top
		case .bottom:
			return .Bottom
		case .leading:
			return .Leading
		case .trailing:
			return .Trailing
		case .width:
			return .Width
		case .height:
			return .Height
		case .centerX:
			return .CenterX
		case .centerY:
			return .CenterY
		case .baseline:
			return .LastBaseline
        case .firstBaseline:
            return .FirstBaseline
        case .lastBaseline:
            return .LastBaseline
		default:
			return .NotAnAttribute
		}
	}
	
	public class func layoutRelationFromEnum(relation:PlanetUI.LayoutRelation) -> NSLayoutRelation {
		
		switch(relation) {
		case .lessThanOrEqual:
			return .LessThanOrEqual
		case .greaterThanOrEqual:
			return .GreaterThanOrEqual
		default:
			return .Equal
		}
	}
	
	//MARK: - convenience view accessors
	
	internal func firstView() -> UIView? {
		if let item = self.firstItem {
			if item == Constraint_parentKeyword {
				
				//avoid an infinite loop if both are looking for super view
				if self.secondItem != nil && self.secondItem! == Constraint_parentKeyword {
					return nil
				}
				return secondView()?.superview
			}
			else {
				let itemObj:AnyObject? = (scope() as? Object)?.objectForId(item)
				if let itemView = itemObj as? View {
					return itemView.view
				}
			}
		}
		return nil
	}
	
	internal func secondView() -> UIView? {
		if let item = self.secondItem {
			if item == Constraint_parentKeyword {
				
				//avoid an infinite loop if both are looking for super view
				if self.firstItem != nil && self.firstItem! == Constraint_parentKeyword {
					return nil
				}
				return firstView()?.superview
			}
			else {
				let itemObj:AnyObject? = (scope() as? Object)?.objectForId(item)
				if let itemView = itemObj as? View {
					return itemView.view
				}
			}
		}
		return nil
	}
	
	//MARK: - loading
	
	public override func gaxbDidPrepare() {
		super.gaxbDidPrepare()
        guard constraint == nil else { return }

        if let first = firstView() {
            let second = secondView()
            
            constraints = makeConstraints()
            if constraints.count == 1 {
                constraint?.identifier = id
            }
            
            first.translatesAutoresizingMaskIntoConstraints = false
            second?.translatesAutoresizingMaskIntoConstraints = false
            
            constraints.forEach { $0.priority = priority }
            
            // attempt to figure out which view to add the constraint to, iOS will crash if we pick the wrong one
            if second != nil && first.isDescendantOfView(second!) {
                second!.addConstraints(constraints)
            } else {
                first.superview?.addConstraints(constraints)
            }
		}
	}
    
    public func makeConstraints() -> [NSLayoutConstraint] {
        guard let first = firstView() else { return [] }
        let second = secondView()
        switch ruleSet {
        case .fillSuperview:
            let superview = first.superview
            return [NSLayoutConstraint(item: first, toItem: superview, equalAttribute: .Top),
                NSLayoutConstraint(item: first, toItem: superview, equalAttribute: .Right),
                NSLayoutConstraint(item: first, toItem: superview, equalAttribute: .Bottom),
                NSLayoutConstraint(item: first, toItem: superview, equalAttribute: .Left)]
        case .equalSize:
            return [NSLayoutConstraint(item: first, toItem: second, equalAttribute: .Width),
                NSLayoutConstraint(item: first, toItem: second, equalAttribute: .Height)]
        case .equalCenter:
            return [NSLayoutConstraint(item:first, toItem: second, equalAttribute: .CenterX),
                NSLayoutConstraint(item:first, toItem: second, equalAttribute: .CenterY)]
        case .square:
            return [NSLayoutConstraint(item: first, attribute: .Width, relatedBy: .Equal, toItem: nil, attribute: .NotAnAttribute, multiplier: 1, constant: CGFloat(constant)),
                NSLayoutConstraint(item: first, attribute: .Height, relatedBy: .Equal, toItem: nil, attribute: .NotAnAttribute, multiplier: 1, constant: CGFloat(constant))]
        default:
            let firstLayoutAttribute = Constraint.layoutAttributeFromEnum(firstAttribute)
            if firstLayoutAttribute == .NotAnAttribute {
                assertionFailure("First layout attribute invalid: \(firstAttribute)")
            }
            let secondLayoutAttribute = Constraint.layoutAttributeFromEnum(secondAttribute)
           return [NSLayoutConstraint(item: first,
                attribute: firstLayoutAttribute,
                relatedBy: Constraint.layoutRelationFromEnum(relation),
                toItem: second,
                attribute: secondLayoutAttribute,
                multiplier: CGFloat(multiplier),
                constant: CGFloat(constant))]
        }
    }
    
}

extension NSLayoutConstraint {
    public convenience init(item: UIView, toItem: UIView?, equalAttribute attribute: NSLayoutAttribute) {
        self.init(item: item, attribute: attribute, relatedBy:.Equal, toItem:toItem, attribute: attribute, multiplier: 1, constant: 0)
    }
}
