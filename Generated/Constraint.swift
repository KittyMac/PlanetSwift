//
// Autogenerated by gaxb at 11:45:55 AM on 01/14/15
//

import UIKit

private let Constraint_parentKeyword = "parent"

//MARK: - ConstraintInterfaceSizeClassMask

//NOTE: refer to this if you need to convert to Swift 2.0 http://stackoverflow.com/questions/24066170/swift-ns-options-style-bitmask-enumerations
public struct ConstraintInterfaceSizeClassMask : RawOptionSetType {
	typealias RawValue = UInt
	private var value: UInt = 0
	init(_ value: UInt) { self.value = value }
	public init(rawValue value: UInt) { self.value = value }
	public init(nilLiteral: ()) { self.value = 0 }
	public static var allZeros: ConstraintInterfaceSizeClassMask { return self(0) }
	static func fromMask(raw: UInt) -> ConstraintInterfaceSizeClassMask { return self(raw) }
	public var rawValue: UInt { return self.value }
	
	static var Any:ConstraintInterfaceSizeClassMask { return self(0b11) }
	static var Compact:ConstraintInterfaceSizeClassMask { return self(0b01) }
	static var Regular:ConstraintInterfaceSizeClassMask { return self(0b10) }
	static var None:ConstraintInterfaceSizeClassMask { return self(0b00) }
}

//MARK: -

public class Constraint: ConstraintBase, PlanetTraitCollectionDelegate {
	
	internal(set) public var constraint:NSLayoutConstraint?
	
	//MARK: - enum conversion
	
	public class func layoutAttributeFromEnum(attribute:PlanetUI.LayoutAttribute) -> NSLayoutAttribute {
		
		switch(attribute) {
		case .left:
			return .Left
		case .right:
			return .Right
		case .top:
			return .Top
		case .bottom:
			return .Bottom
		case .leading:
			return .Leading
		case .trailing:
			return .Trailing
		case .width:
			return .Width
		case .height:
			return .Height
		case .centerX:
			return .CenterX
		case .centerY:
			return .CenterY
		case .baseline:
			return .Baseline
		default:
			return .NotAnAttribute
		}
	}
	
	public class func layoutRelationFromEnum(relation:PlanetUI.LayoutRelation) -> NSLayoutRelation {
		
		switch(relation) {
		case .lessThanOrEqual:
			return .LessThanOrEqual
		case .greaterThanOrEqual:
			return .GreaterThanOrEqual
		default:
			return .Equal
		}
	}
	
	//MARK: - convenience view accessors
	
	internal func firstView() -> UIView? {
		if let item = self.firstItem {
			if item == Constraint_parentKeyword {
				
				//avoid an infinite loop if both are looking for super view
				if self.secondItem != nil && self.secondItem! == Constraint_parentKeyword {
					return nil
				}
				return secondView()?.superview
			}
			else {
				let itemObj:AnyObject? = (scope() as? Object)?.objectForId(item)
				if let itemView = itemObj as? View {
					return itemView.view
				}
			}
		}
		return nil
	}
	
	internal func secondView() -> UIView? {
		if let item = self.secondItem {
			if item == Constraint_parentKeyword {
				
				//avoid an infinite loop if both are looking for super view
				if self.firstItem != nil && self.firstItem! == Constraint_parentKeyword {
					return nil
				}
				return firstView()?.superview
			}
			else {
				let itemObj:AnyObject? = (scope() as? Object)?.objectForId(item)
				if let itemView = itemObj as? View {
					return itemView.view
				}
			}
		}
		return nil
	}
	
	//MARK: - loading
	
	public override func gaxbDidPrepare() {
		super.gaxbDidPrepare()
		
		if constraint == nil {
			
			if let first = firstView() {
				
				let second = secondView()
				
				constraint = NSLayoutConstraint(item: first,
					attribute: Constraint.layoutAttributeFromEnum(firstAttribute),
					relatedBy: Constraint.layoutRelationFromEnum(relation),
					toItem: second,
					attribute: Constraint.layoutAttributeFromEnum(secondAttribute),
					multiplier: CGFloat(multiplier),
					constant: CGFloat(constant))
				
				constraint?.identifier = self.id
				constraint?.priority = priority
				
				first.setTranslatesAutoresizingMaskIntoConstraints(false)
				second?.setTranslatesAutoresizingMaskIntoConstraints(false)
				
				//attempt to figure out which view to add the constraint to, iOS will crash if we pick the wrong one
				if second != nil && first.isDescendantOfView(second!) {
					second!.addConstraint(constraint!)
				}
				else {
					first.superview?.addConstraint(constraint!)
				}
			}
		}
	}
	
	//MARK: - PlanetTraitCollectionDelegate
	
	public func willTransitionToTraitCollection(newCollection: UITraitCollection) {
		
		if let constraint = constraint {
			
			//get the settings that correspond to the current width class
			let mask:ConstraintInterfaceSizeClassMask
			switch newCollection.horizontalSizeClass {
			case .Compact:
				mask = compactWidth ?? ConstraintInterfaceSizeClassMask.Any;
			case .Regular:
				mask = regularWidth ?? ConstraintInterfaceSizeClassMask.Any;
			case .Unspecified:
				mask = ConstraintInterfaceSizeClassMask.None;//should this be 'Any'?
			}
			
			//check if we're matching the height class at this width
			let shouldEnable:Bool
			switch newCollection.verticalSizeClass {
			case .Compact:
				shouldEnable = (mask & ConstraintInterfaceSizeClassMask.Compact).rawValue != 0
			case .Regular:
				shouldEnable = (mask & ConstraintInterfaceSizeClassMask.Regular).rawValue != 0
			case .Unspecified:
				shouldEnable = false;
			}
			constraint.active = shouldEnable
		}
	}
	
}
